<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alumni Network Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }

        .main-content {
            flex: 1;
            position: relative;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
        }

        .header h1 {
            color: white;
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .header p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1rem;
        }

        .search-container {
            margin-bottom: 25px;
        }

        .search-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .legend {
            margin-bottom: 25px;
        }

        .legend h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .most-connected {
            margin-bottom: 25px;
        }

        .most-connected h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .alumni-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 5px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .alumni-item:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateX(5px);
        }

        .alumni-rank {
            background: #667eea;
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            margin-right: 10px;
        }

        .alumni-info {
            flex: 1;
        }

        .alumni-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
        }

        .alumni-connections {
            font-size: 0.8rem;
            color: #666;
        }

        .network-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .tooltip.show {
            opacity: 1;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .control-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            margin: 2px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }

        .stats {
            margin-top: 20px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }

        .stats h4 {
            color: #333;
            margin-bottom: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 200px;
                order: 2;
            }
            
            .main-content {
                order: 1;
                height: calc(100vh - 200px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="search-container">
                <select class="search-input" id="alumniSelect">
                    <option value="">üë• Select an alumni to highlight...</option>
                </select>
            </div>
            
            <div class="legend">
                <h3>üìä Node Legend</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>High Influence (15+ connections)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffa726;"></div>
                    <span>Medium Influence (8-14 connections)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #66bb6a;"></div>
                    <span>Low Influence (3-7 connections)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #90caf9;"></div>
                    <span>Minimal Influence (1-2 connections)</span>
                </div>
            </div>
            
            <div class="most-connected">
                <h3>üåü Most Connected Alumni</h3>
                <div id="alumniRanking"></div>
            </div>
            
            <div class="stats">
                <h4>üìà Network Statistics</h4>
                <div class="stat-item">
                    <span>Total Alumni:</span>
                    <span id="totalAlumni">0</span>
                </div>
                <div class="stat-item">
                    <span>Total Connections:</span>
                    <span id="totalConnections">0</span>
                </div>
                <div class="stat-item">
                    <span>Average Connections:</span>
                    <span id="avgConnections">0</span>
                </div>
                <div class="stat-item">
                    <span>Most Connected:</span>
                    <span id="mostConnected">-</span>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="header">
                <h1>üåê Alumni Network Visualization</h1>
                <p>Explore connections and influence within the alumni community</p>
            </div>
            
            <div class="controls">
                <button class="control-button" onclick="resetZoom()">üîç Reset Zoom</button>
                <button class="control-button" onclick="togglePhysics()">‚ö° Toggle Physics</button>
                <button class="control-button" onclick="centerNetwork()">üéØ Center Network</button>
            </div>
            
            <div class="network-container" id="networkContainer"></div>
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <script>
        // Global variables for alumni data
        let alumniData = { nodes: [], links: [] };
        let rawAlumniData = [];

        // Google Sheets CSV URLs (same as main app)
        const GOOGLE_SHEETS_PRIMARY_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRNZd56-34Smsl9_wFik9OsErpCSN6yDjRCh-3Rbt7i2o0szFf6J8JzsaUXB_Xw0onxOcpMMhxBH-_h/pub?output=csv';
        const GOOGLE_SHEETS_ALTERNATIVE_URL = 'https://docs.google.com/spreadsheets/d/1zeUrlPCj7ZAmw1SHd8nvnYky5mCvpKZtNonb6oXfPA0/export?format=csv&gid=0';

        // Load real alumni data
        async function loadRealAlumniData() {
            try {
                console.log('üîÑ Loading real alumni data...');
                
                let csvData;
                try {
                    // Try primary Google Sheets URL first
                    console.log('üåê Trying primary Google Sheets URL...');
                    const response = await fetch(GOOGLE_SHEETS_PRIMARY_URL + '&timestamp=' + Date.now(), {
                        method: 'GET',
                        mode: 'cors',
                        headers: { 'Accept': 'text/csv' }
                    });
                    
                    if (response.ok) {
                        csvData = await response.text();
                        
                        // Check if we got HTML instead of CSV
                        if (csvData.includes('<HTML>') || csvData.includes('<html>') || csvData.includes('Temporary Redirect')) {
                            throw new Error('Got HTML instead of CSV from primary URL');
                        }
                        console.log('‚úÖ Primary Google Sheets data loaded');
                    } else {
                        throw new Error(`Primary URL failed: ${response.status}`);
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Primary Google Sheets failed, trying alternative URL:', error);
                    try {
                        // Try alternative Google Sheets URL
                        const altResponse = await fetch(GOOGLE_SHEETS_ALTERNATIVE_URL, {
                            method: 'GET',
                            mode: 'cors'
                        });
                        
                        if (altResponse.ok) {
                            csvData = await altResponse.text();
                            if (!csvData.includes('<HTML>') && !csvData.includes('<html>')) {
                                console.log('‚úÖ Alternative Google Sheets data loaded');
                            } else {
                                throw new Error('Alternative URL also returned HTML');
                            }
                        } else {
                            throw new Error(`Alternative URL failed: ${altResponse.status}`);
                        }
                    } catch (altError) {
                        console.warn('‚ö†Ô∏è Alternative Google Sheets also failed, trying local CSV files:', altError);
                        try {
                            // Try test CSV first
                            console.log('üß™ Trying test CSV file...');
                            const testResponse = await fetch('./data/test-alumni.csv?t=' + Date.now());
                            if (testResponse.ok) {
                                csvData = await testResponse.text();
                                console.log('‚úÖ Test CSV data loaded');
                            } else {
                                // Try main alumni CSV file
                                console.log('üìä Trying main alumni CSV file...');
                                const fallbackResponse = await fetch('./data/alumni.csv?t=' + Date.now());
                                if (!fallbackResponse.ok) throw new Error('Local CSV not found');
                                csvData = await fallbackResponse.text();
                                console.log('‚úÖ Main alumni CSV data loaded');
                            }
                        } catch (csvError) {
                            console.warn('‚ö†Ô∏è All data sources failed, using fallback data:', csvError);
                            createFallbackData();
                            return;
                        }
                    }
                }

                // Parse CSV data
                rawAlumniData = parseCSV(csvData);
                console.log(`üìä Parsed ${rawAlumniData.length} alumni records`);
                
                // Debug: Show first few names
                if (rawAlumniData.length > 0) {
                    console.log('üë• First few alumni names:', rawAlumniData.slice(0, 5).map(a => a.name));
                    console.log('üìã Sample alumni data:', rawAlumniData.slice(0, 2));
                } else {
                    console.error('üö® No alumni data was parsed from CSV!');
                    console.log('üìÑ Raw CSV data sample:', csvData.substring(0, 500));
                }

                if (rawAlumniData.length === 0) {
                    console.warn('‚ö†Ô∏è No valid alumni data found, using fallback');
                    createFallbackData();
                    return;
                }

                console.log('‚úÖ Real alumni data loaded successfully - proceeding with network generation');

                // Convert to network format
                generateNetworkData();
                
                // Populate alumni dropdown
                populateAlumniDropdown();
                
                // Initialize network visualization
                initNetwork();
                
            } catch (error) {
                console.error('‚ùå Failed to load alumni data:', error);
                createFallbackData();
            }
        }

        // Parse CSV data (improved method)
        function parseCSV(csvText) {
            try {
                console.log('üîÑ Parsing CSV data...');
                console.log('üìÑ CSV length:', csvText.length, 'characters');
                console.log('üìÑ First 200 chars:', csvText.substring(0, 200));
                
                const lines = csvText.trim().split('\n');
                if (lines.length < 2) {
                    console.warn('‚ö†Ô∏è CSV has insufficient data');
                    return [];
                }

                const headers = parseCSVLine(lines[0]);
                console.log('üìã CSV Headers:', headers);
                
                // Check for photo-related headers
                const photoHeaders = headers.filter(h => 
                    h.toLowerCase().includes('photo') || 
                    h.toLowerCase().includes('image') || 
                    h.toLowerCase().includes('picture') ||
                    h.toLowerCase().includes('avatar')
                );
                if (photoHeaders.length > 0) {
                    console.log('üì∏ Found photo-related headers:', photoHeaders);
                } else {
                    console.log('‚ö†Ô∏è No photo-related headers found in CSV');
                }
                
                const alumni = [];
                for (let i = 1; i < lines.length; i++) {
                    try {
                        const values = parseCSVLine(lines[i]);
                        if (values.length < 3) continue; // Skip rows with too few columns
                        
                        const alumniData = {};
                        headers.forEach((header, index) => {
                            alumniData[header] = values[index] ? values[index].trim() : '';
                        });

                        // Convert to standardized format
                        const standardized = convertToStandardFormat(alumniData);
                        if (standardized.name && standardized.name !== 'Anonymous' && standardized.name.trim() !== '') {
                            alumni.push(standardized);
                        }
                    } catch (rowError) {
                        console.warn(`‚ö†Ô∏è Error parsing row ${i}:`, rowError);
                    }
                }
                
                console.log(`üìä Successfully parsed ${alumni.length} valid alumni`);
                return alumni;
            } catch (error) {
                console.error('‚ùå Error parsing CSV:', error);
                return [];
            }
        }

        // Parse CSV line handling quoted fields
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current.trim());
            return result.map(field => field.replace(/^"|"$/g, '')); // Remove surrounding quotes
        }

        // Convert raw data to standardized format
        function convertToStandardFormat(rawAlumni) {
            // Try multiple possible name fields
            const nameFields = ['name', 'Name', 'full_name', 'Full Name', 'Full name', 'FullName', 'fullName'];
            const firstNameFields = ['first_name', 'First Name', 'firstName', 'first'];
            const lastNameFields = ['last_name', 'Last Name', 'lastName', 'last'];
            
            let name = '';
            
            // Try full name fields first
            for (const field of nameFields) {
                if (rawAlumni[field] && rawAlumni[field].trim()) {
                    name = rawAlumni[field].trim();
                    break;
                }
            }
            
            // If no full name, try combining first + last
            if (!name) {
                const firstName = firstNameFields.find(f => rawAlumni[f]) ? rawAlumni[firstNameFields.find(f => rawAlumni[f])].trim() : '';
                const lastName = lastNameFields.find(f => rawAlumni[f]) ? rawAlumni[lastNameFields.find(f => rawAlumni[f])].trim() : '';
                if (firstName || lastName) {
                    name = `${firstName} ${lastName}`.trim();
                }
            }

            // Get other fields with multiple possible names
            const degreeFields = ['degree', 'Degree', 'field_of_study', 'Field of Study', 'major', 'Major', 'study_field'];
            const classFields = ['class', 'Class', 'graduation_year', 'Graduation Year', 'year', 'Year'];
            const industryFields = ['industry', 'Industry', 'current_industry', 'Current Industry', 'sector'];
            const attendingFields = ['attending', 'Attending', 'summit_2025', 'Summit 2025', 'will_attend'];

            const degree = degreeFields.find(f => rawAlumni[f]) ? rawAlumni[degreeFields.find(f => rawAlumni[f])].trim() : '';
            const classYear = classFields.find(f => rawAlumni[f]) ? rawAlumni[classFields.find(f => rawAlumni[f])].trim() : '';
            const industry = industryFields.find(f => rawAlumni[f]) ? rawAlumni[industryFields.find(f => rawAlumni[f])].trim() : '';
            const attendingValue = attendingFields.find(f => rawAlumni[f]) ? rawAlumni[attendingFields.find(f => rawAlumni[f])] : '';
            const attending = attendingValue === 'Yes' || attendingValue === 'yes' || attendingValue === 'TRUE' || attendingValue === true;

            // Get photo field
            const photoFields = ['photo', 'Photo', 'image', 'Image', 'picture', 'Picture', 'avatar', 'profile_pic', 'profile_image'];
            const photo = photoFields.find(f => rawAlumni[f]) ? rawAlumni[photoFields.find(f => rawAlumni[f])].trim() : '';

            const result = {
                name: name || 'Anonymous',
                class: classYear,
                degree: degree,
                industry: industry,
                attending: attending,
                company: rawAlumni.company || rawAlumni.Company || rawAlumni.current_company || '',
                position: rawAlumni.position || rawAlumni.Position || rawAlumni.job_title || '',
                location: rawAlumni.location || rawAlumni.Location || rawAlumni.city || '',
                photo: photo
            };
            
            // Debug: Log the conversion for the first few entries
            if (Math.random() < 0.1) { // Log ~10% of conversions to avoid spam
                console.log('üîÑ Converting raw alumni:', rawAlumni);
                console.log('‚û°Ô∏è To standardized format:', result);
                if (photo) {
                    console.log('üì∏ Found photo URL:', photo);
                }
            }
            
            return result;
        }

        // Create fallback data if real data fails
        function createFallbackData() {
            console.log('üö® WARNING: Using fallback data because real data failed to load!');
            console.log('üö® This means you are seeing demo names, not real alumni data');
            rawAlumniData = [
                { name: "DEMO: Sarah Chen", class: "2020", degree: "Computer Science", industry: "Tech", attending: true },
                { name: "DEMO: Michael Rodriguez", class: "2020", degree: "Computer Science", industry: "Tech", attending: true },
                { name: "DEMO: Emily Johnson", class: "2019", degree: "Business Administration", industry: "Finance", attending: false },
                { name: "DEMO: David Kim", class: "2019", degree: "Business Administration", industry: "Consulting", attending: true },
                { name: "DEMO: Jessica Williams", class: "2021", degree: "Engineering", industry: "Manufacturing", attending: true }
            ];
            
            // Convert to network format
            generateNetworkData();
            
            // Populate alumni dropdown
            populateAlumniDropdown();
            
            // Initialize network visualization
            initNetwork();
        }

        // Generate network connections based on alumni data
        function generateNetworkData() {
            console.log(`üîÑ Converting ${rawAlumniData.length} alumni to network nodes...`);
            
            // Convert alumni to nodes
            alumniData.nodes = rawAlumniData.map((alumni, index) => ({
                id: `alumni_${index}`,
                name: alumni.name,
                class: alumni.class,
                degree: alumni.degree,
                industry: alumni.industry,
                company: alumni.company,
                position: alumni.position,
                location: alumni.location,
                attending: alumni.attending,
                photo: alumni.photo || alumni.image || alumni.picture || '',
                rawData: alumni // Keep reference to original data
            }));
            
            console.log(`‚úÖ Created ${alumniData.nodes.length} nodes with names:`, alumniData.nodes.slice(0, 5).map(n => n.name));

            // Generate connections based on degree and class
            alumniData.links = [];
            
            for (let i = 0; i < alumniData.nodes.length; i++) {
                for (let j = i + 1; j < alumniData.nodes.length; j++) {
                    const nodeA = alumniData.nodes[i];
                    const nodeB = alumniData.nodes[j];
                    
                    let shouldConnect = false;
                    let connectionType = 'friendship';
                    
                    // Same degree - high chance of connection
                    if (nodeA.degree === nodeB.degree) {
                        shouldConnect = Math.random() < 0.7; // 70% chance
                        connectionType = 'professional';
                    }
                    // Same class - medium chance of connection
                    else if (nodeA.class === nodeB.class) {
                        shouldConnect = Math.random() < 0.5; // 50% chance
                        connectionType = 'cohort';
                    }
                    // Different degree and class - low chance
                    else {
                        shouldConnect = Math.random() < 0.15; // 15% chance
                        connectionType = 'friendship';
                    }
                    
                    if (shouldConnect) {
                        alumniData.links.push({
                            source: nodeA.id,
                            target: nodeB.id,
                            type: connectionType
                        });
                    }
                }
            }

            console.log(`üîó Generated ${alumniData.links.length} connections between ${alumniData.nodes.length} alumni`);
        }

        // Populate the alumni dropdown
        function populateAlumniDropdown() {
            const select = document.getElementById('alumniSelect');
            select.innerHTML = '<option value="">üë• Select an alumni to highlight...</option>';
            
            // Sort alumni by name
            const sortedAlumni = [...alumniData.nodes].sort((a, b) => a.name.localeCompare(b.name));
            
            sortedAlumni.forEach(alumni => {
                const option = document.createElement('option');
                option.value = alumni.id;
                option.textContent = `${alumni.name} (${alumni.class}, ${alumni.degree})`;
                select.appendChild(option);
            });
        }



        // Network visualization variables
        let svg, simulation, nodes, links, tooltip;
        let width, height;
        let physicsEnabled = true;
        let selectedNode = null;

        // Initialize the network visualization
        function initNetwork() {
            // Set up dimensions
            const container = d3.select("#networkContainer");
            const containerRect = container.node().getBoundingClientRect();
            width = containerRect.width;
            height = containerRect.height;

            // Create SVG
            svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on("zoom", (event) => {
                    svg.select("g").attr("transform", event.transform);
                });

            svg.call(zoom);

            // Create main group for zooming
            const g = svg.append("g");

            // Create tooltip
            tooltip = d3.select("#tooltip");

            // Process data and calculate centrality
            processNetworkData();

            // Create force simulation
            simulation = d3.forceSimulation(alumniData.nodes)
                .force("link", d3.forceLink(alumniData.links).id(d => d.id).distance(80))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(d => getNodeRadius(d) + 5));

            // Create links
            const link = g.append("g")
                .selectAll("line")
                .data(alumniData.links)
                .join("line")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .attr("stroke-width", d => getLinkWidth(d));

            // Create nodes with profile images (simplified)
            const node = g.append("g")
                .selectAll("g")
                .data(alumniData.nodes)
                .join("g")
                .style("cursor", "pointer")
                .call(d3.drag()
                    .on("start", dragStarted)
                    .on("drag", dragged)
                    .on("end", dragEnded));

            // Add background circles first
            node.append("circle")
                .attr("r", d => getNodeRadius(d))
                .attr("fill", d => getNodeColor(d))
                .attr("stroke", "#fff")
                .attr("stroke-width", 2);

            // Add text labels on circles (fallback)
            node.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "0.35em")
                .attr("font-size", "10px")
                .attr("font-weight", "bold")
                .attr("fill", "white")
                .text(d => {
                    const names = d.name.split(' ');
                    return names.map(n => n[0]).join('').substring(0, 2).toUpperCase();
                });

            // Try to add real images on top of circles
            node.each(function(d) {
                const nodeGroup = d3.select(this);
                const imageUrl = getProfileImageUrl(d);
                
                // Only try to load image if we have a real URL (not generated avatar)
                if (imageUrl && !imageUrl.includes('ui-avatars.com')) {
                    console.log(`üì∏ Attempting to load real image for ${d.name}: ${imageUrl}`);
                    
                    // Create a test image
                    const testImg = new Image();
                    testImg.crossOrigin = "anonymous";
                    
                    testImg.onload = function() {
                        console.log(`‚úÖ Real image loaded for ${d.name}`);
                        
                        // Hide the text (we'll show the image instead)
                        nodeGroup.select("text").style("display", "none");
                        
                        // Add the real image
                        nodeGroup.append("image")
                            .attr("x", -getNodeRadius(d))
                            .attr("y", -getNodeRadius(d))
                            .attr("width", getNodeRadius(d) * 2)
                            .attr("height", getNodeRadius(d) * 2)
                            .attr("href", imageUrl)
                            .style("border-radius", "50%");
                    };
                    
                    testImg.onerror = function() {
                        console.log(`‚ùå Real image failed for ${d.name}, keeping initials`);
                        // Keep the circle and initials as fallback
                    };
                    
                    testImg.src = imageUrl;
                } else {
                    console.log(`üé® Using initials for ${d.name} (no real image URL)`);
                }
            });



            // Add labels
            const label = g.append("g")
                .selectAll("text")
                .data(alumniData.nodes)
                .join("text")
                .text(d => d.name)
                .attr("font-size", "12px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .attr("text-anchor", "middle")
                .attr("dy", -15)
                .style("pointer-events", "none");

            // Store references
            links = link;
            nodes = node;

            // Add event listeners
            node.on("mouseover", showTooltip)
                .on("mouseout", hideTooltip)
                .on("click", selectNode);

            // Update positions on simulation tick
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);

                // Update clipping paths positions
                defs.selectAll("clipPath circle")
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });

            // Initialize UI
            updateSidebar();
            setupSearch();
        }

        // Process network data and calculate centrality
        function processNetworkData() {
            // Calculate degree centrality for each node
            alumniData.nodes.forEach(node => {
                node.connections = alumniData.links.filter(link => 
                    link.source === node.id || link.target === node.id
                ).length;
                node.centrality = node.connections;
            });

            // Sort nodes by centrality
            alumniData.nodes.sort((a, b) => b.centrality - a.centrality);
        }

        // Get node radius based on centrality
        function getNodeRadius(node) {
            const baseRadius = 8;
            const maxRadius = 25;
            const maxConnections = Math.max(...alumniData.nodes.map(n => n.connections));
            return baseRadius + (node.connections / maxConnections) * (maxRadius - baseRadius);
        }

        // Get node color based on influence level
        function getNodeColor(node) {
            if (node.connections >= 15) return "#ff6b6b"; // High influence
            if (node.connections >= 8) return "#ffa726";  // Medium influence
            if (node.connections >= 3) return "#66bb6a";  // Low influence
            return "#90caf9"; // Minimal influence
        }

        // Get link width based on connection type
        function getLinkWidth(link) {
            const widths = {
                professional: 3,
                cohort: 2,
                friendship: 1.5
            };
            return widths[link.type] || 1;
        }

        // Get profile image URL for alumni
        function getProfileImageUrl(alumni) {
            console.log(`üñºÔ∏è Getting image for ${alumni.name}:`, alumni);
            
            let imageUrl = null;
            
            // Try to get image from alumni data
            if (alumni.rawData && alumni.rawData.photo) {
                console.log(`‚úÖ Found photo in rawData: ${alumni.rawData.photo}`);
                imageUrl = alumni.rawData.photo;
            }
            // Try direct photo field
            else if (alumni.photo && alumni.photo.trim()) {
                console.log(`‚úÖ Found direct photo: ${alumni.photo}`);
                imageUrl = alumni.photo.trim();
            }
            // Try common image field names
            else {
                const imageFields = ['photo', 'image', 'picture', 'avatar', 'profile_pic', 'profile_image', 'Photo', 'Image'];
                for (const field of imageFields) {
                    if (alumni[field] && alumni[field].trim()) {
                        console.log(`‚úÖ Found image in field ${field}: ${alumni[field]}`);
                        imageUrl = alumni[field].trim();
                        break;
                    }
                }
            }
            
            if (imageUrl) {
                // Try to fix common URL issues before returning
                imageUrl = fixImageUrl(imageUrl);
                console.log(`üîß Processed image URL: ${imageUrl}`);
                return imageUrl;
            }
            
            console.log(`‚ö†Ô∏è No photo found for ${alumni.name}, using generated avatar`);
            
            // Generate avatar using UI Avatars service as fallback
            const name = alumni.name || 'Anonymous';
            const color = getNodeColor(alumni).replace('#', '');
            
            return `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&size=128&background=${color}&color=fff&bold=true`;
        }

        // Fix common image URL issues
        function fixImageUrl(url) {
            if (!url) return url;
            
            // Fix Google Drive URLs
            if (url.includes('drive.google.com/file/d/')) {
                const fileIdMatch = url.match(/\/d\/([a-zA-Z0-9-_]+)/);
                if (fileIdMatch) {
                    return `https://drive.google.com/uc?export=view&id=${fileIdMatch[1]}`;
                }
            }
            
            // Fix Dropbox URLs
            if (url.includes('dropbox.com') && !url.includes('?raw=1')) {
                return url.replace('?dl=0', '?raw=1').replace('?dl=1', '?raw=1');
            }
            
            return url;
        }

        // Try alternative image loading methods
        function tryAlternativeImageLoading(nodeGroup, d, originalUrl) {
            const alternatives = [
                // Try with CORS proxy
                `https://api.allorigins.win/raw?url=${encodeURIComponent(originalUrl)}`,
                // Try with different CORS proxy
                `https://cors-anywhere.herokuapp.com/${originalUrl}`,
                // Try direct URL without CORS (might work in some cases)
                originalUrl
            ];
            
            let attemptIndex = 0;
            
            function tryNextAlternative() {
                if (attemptIndex >= alternatives.length) {
                    // All alternatives failed, use generated avatar
                    console.log(`üé® All alternatives failed for ${d.name}, using generated avatar`);
                    createGeneratedAvatar(nodeGroup, d);
                    return;
                }
                
                const altUrl = alternatives[attemptIndex];
                console.log(`üîÑ Trying alternative ${attemptIndex + 1} for ${d.name}: ${altUrl}`);
                
                const img = new Image();
                img.onload = function() {
                    console.log(`‚úÖ Alternative ${attemptIndex + 1} worked for ${d.name}`);
                    nodeGroup.append("image")
                        .attr("x", -getNodeRadius(d))
                        .attr("y", -getNodeRadius(d))
                        .attr("width", getNodeRadius(d) * 2)
                        .attr("height", getNodeRadius(d) * 2)
                        .attr("href", altUrl)
                        .attr("clip-path", `url(#clip-${d.id})`);
                };
                
                img.onerror = function() {
                    console.log(`‚ùå Alternative ${attemptIndex + 1} failed for ${d.name}`);
                    attemptIndex++;
                    setTimeout(tryNextAlternative, 100); // Small delay between attempts
                };
                
                img.src = altUrl;
            }
            
            tryNextAlternative();
        }

        // Create generated avatar as final fallback
        function createGeneratedAvatar(nodeGroup, d) {
            const name = d.name || 'Anonymous';
            const color = getNodeColor(d).replace('#', '');
            const avatarUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&size=128&background=${color}&color=fff&bold=true`;
            
            console.log(`üé® Creating generated avatar for ${d.name}: ${avatarUrl}`);
            
            // Test the generated avatar URL
            const img = new Image();
            img.onload = function() {
                nodeGroup.append("image")
                    .attr("x", -getNodeRadius(d))
                    .attr("y", -getNodeRadius(d))
                    .attr("width", getNodeRadius(d) * 2)
                    .attr("height", getNodeRadius(d) * 2)
                    .attr("href", avatarUrl)
                    .attr("clip-path", `url(#clip-${d.id})`);
            };
            
            img.onerror = function() {
                // If even the generated avatar fails, create a colored circle
                console.log(`‚ùå Generated avatar failed for ${d.name}, using colored circle`);
                nodeGroup.append("circle")
                    .attr("r", getNodeRadius(d))
                    .attr("fill", getNodeColor(d))
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 2);
            };
            
            img.src = avatarUrl;
        }

        // Drag functions
        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Tooltip functions
        function showTooltip(event, d) {
            const connectedNodes = getConnectedNodes(d);
            const attendingStatus = d.attending ? '‚úÖ Attending Summit' : '‚ùå Not Attending';
            tooltip
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px")
                .html(`
                    <strong>${d.name}</strong><br>
                    ${d.class ? `Class of ${d.class}<br>` : ''}
                    ${d.degree ? `${d.degree}<br>` : ''}
                    ${d.industry ? `Industry: ${d.industry}<br>` : ''}
                    ${d.company ? `Company: ${d.company}<br>` : ''}
                    ${d.position ? `Position: ${d.position}<br>` : ''}
                    ${d.location ? `Location: ${d.location}<br>` : ''}
                    ${attendingStatus}<br>
                    <strong>${d.connections} connections</strong><br>
                    <em>Connected to: ${connectedNodes.slice(0, 3).map(n => n.name).join(', ')}${connectedNodes.length > 3 ? '...' : ''}</em>
                `)
                .classed("show", true);
        }

        function hideTooltip() {
            tooltip.classed("show", false);
        }

        // Get connected nodes
        function getConnectedNodes(node) {
            const connected = [];
            alumniData.links.forEach(link => {
                if (link.source.id === node.id) connected.push(link.target);
                if (link.target.id === node.id) connected.push(link.source);
            });
            return connected;
        }

        // Select node and show ONLY their connections (isolated view)
        function selectNode(event, d) {
            selectedNode = d;
            console.log(`üéØ Isolating connections for: ${d.name}`);
            console.log(`üé¨ Starting re-animation sequence...`);
            
            // Get connected node IDs
            const connectedNodeIds = new Set([d.id]); // Include the selected node itself
            const relevantLinks = [];
            
            // Find all connections to/from this node
            alumniData.links.forEach(link => {
                if (link.source.id === d.id || link.target.id === d.id) {
                    connectedNodeIds.add(link.source.id);
                    connectedNodeIds.add(link.target.id);
                    relevantLinks.push(link);
                }
            });
            
            console.log(`üîó Found ${relevantLinks.length} connections to ${connectedNodeIds.size - 1} other alumni`);
            
            // STEP 1: Reset all elements to center position and hide them
            const centerX = svg.attr("width") / 2 || 400;
            const centerY = svg.attr("height") / 2 || 300;
            
            // Reset ALL nodes to center (including ones we won't show)
            nodes
                .attr("transform", `translate(${centerX}, ${centerY})`)
                .attr("opacity", 0);
            
            // Reset ALL links to center
            links
                .attr("x1", centerX).attr("y1", centerY)
                .attr("x2", centerX).attr("y2", centerY)
                .attr("opacity", 0);
            
            // Hide all labels
            svg.selectAll("text").attr("opacity", 0);
            
            // STEP 2: Restart simulation to get fresh positions
            simulation.alpha(0.8).restart();
            
            // STEP 3: After a brief pause, animate elements to their final positions
            setTimeout(() => {
                console.log(`‚ú® Starting animated reveal for ${connectedNodeIds.size} connected nodes...`);
                
                // Animate connected nodes with staggered timing
                const connectedNodesArray = nodes.filter(node => connectedNodeIds.has(node.id));
                
                connectedNodesArray
                    .transition()
                    .duration(1000)
                    .delay((node, i) => i * 80) // Staggered animation every 80ms
                    .ease(d3.easeBackOut.overshoot(1.2))
                    .attr("transform", node => `translate(${node.x}, ${node.y})`)
                    .attr("opacity", 1);
                
                // Animate relevant links after nodes start moving
                setTimeout(() => {
                    links.filter(link => 
                        connectedNodeIds.has(link.source.id) && connectedNodeIds.has(link.target.id)
                    )
                    .transition()
                    .duration(800)
                    .delay((link, i) => i * 50)
                    .ease(d3.easeQuadOut)
                    .attr("x1", link => link.source.x)
                    .attr("y1", link => link.source.y)
                    .attr("x2", link => link.target.x)
                    .attr("y2", link => link.target.y)
                    .attr("opacity", 0.8);
                }, 300);
                
                // Animate labels after nodes
                setTimeout(() => {
                    svg.selectAll("text")
                        .filter(node => connectedNodeIds.has(node.id))
                        .transition()
                        .duration(600)
                        .delay((node, i) => i * 40)
                        .ease(d3.easeQuadOut)
                        .attr("opacity", 1);
                }, 500);
                
                // Apply final styling after animation completes
                setTimeout(() => {
                    // Update border thickness for selected node
                    nodes.selectAll("circle")
                        .attr("stroke-width", function() {
                            const nodeData = d3.select(this.parentNode).datum();
                            return nodeData.id === d.id ? 5 : 3;
                        });
                    
                    // Update dropdown selection
                    document.getElementById("alumniSelect").value = d.id;
                    
                    // Show notification
                    const connectedCount = connectedNodeIds.size - 1;
                    showIsolationNotification(d.name, connectedCount);
                    
                    console.log(`üéâ Re-animation complete!`);
                }, 1200);
                
            }, 150); // Small delay to let simulation initialize
        }

        // Reset selection - show all nodes and links
        function resetSelection() {
            selectedNode = null;
            console.log(`üîÑ Resetting to show all nodes with animation...`);
            
            // STEP 1: Hide everything first
            nodes.attr("opacity", 0);
            links.attr("opacity", 0);
            svg.selectAll("text").attr("opacity", 0);
            
            // STEP 2: Restart simulation for fresh positioning
            simulation.alpha(0.6).restart();
            
            // STEP 3: Animate all nodes back in with staggered timing
            setTimeout(() => {
                console.log(`‚ú® Animating all ${alumniData.nodes.length} nodes back in...`);
                
                // Animate all nodes
                nodes
                    .transition()
                    .duration(800)
                    .delay((d, i) => i * 30) // Faster stagger for more nodes
                    .ease(d3.easeBackOut)
                    .attr("opacity", 1);
                
                // Animate all links
                setTimeout(() => {
                    links
                        .transition()
                        .duration(600)
                        .delay((d, i) => i * 10)
                        .ease(d3.easeQuadOut)
                        .attr("opacity", 0.6);
                }, 200);
                
                // Animate all labels
                setTimeout(() => {
                    svg.selectAll("text")
                        .transition()
                        .duration(500)
                        .delay((d, i) => i * 20)
                        .ease(d3.easeQuadOut)
                        .attr("opacity", 1);
                }, 400);
                
                // Apply final styling
                setTimeout(() => {
                    // Reset border thickness
                    nodes.selectAll("circle").attr("stroke-width", 3);
                    
                    // Reset dropdown
                    document.getElementById("alumniSelect").value = "";
                    
                    console.log(`üéâ Reset animation complete!`);
                }, 1000);
                
            }, 100);
        }

        // Show isolation notification
        function showIsolationNotification(name, connectionCount) {
            // Create notification element if it doesn't exist
            let notification = document.getElementById('isolationNotification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'isolationNotification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(102, 126, 234, 0.9);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 600;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                    z-index: 1000;
                    transition: all 0.3s ease;
                    backdrop-filter: blur(10px);
                `;
                document.body.appendChild(notification);
            }
            
            notification.innerHTML = `üéØ <strong>${name}</strong><br>Connected to ${connectionCount} alumni`;
            notification.style.opacity = '1';
            notification.style.transform = 'translateY(0)';
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (notification) {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateY(-20px)';
                }
            }, 3000);
        }

        // Update sidebar with rankings and stats
        function updateSidebar() {
            // Update rankings
            const ranking = d3.select("#alumniRanking");
            ranking.selectAll(".alumni-item").remove();

            const topAlumni = alumniData.nodes.slice(0, 10);
            ranking.selectAll(".alumni-item")
                .data(topAlumni)
                .join("div")
                .attr("class", "alumni-item")
                .html((d, i) => `
                    <div class="alumni-rank">${i + 1}</div>
                    <div class="alumni-info">
                        <div class="alumni-name">${d.name}</div>
                        <div class="alumni-connections">${d.connections} connections</div>
                    </div>
                `)
                .on("click", (event, d) => {
                    selectNode(event, d);
                    // Center the view on selected node
                    const transform = d3.zoomIdentity
                        .translate(width / 2 - d.x, height / 2 - d.y)
                        .scale(1.5);
                    svg.transition().duration(750).call(
                        d3.zoom().transform, transform
                    );
                });

            // Update stats
            const totalConnections = alumniData.links.length;
            const avgConnections = (totalConnections * 2 / alumniData.nodes.length).toFixed(1);
            const mostConnected = alumniData.nodes[0];

            document.getElementById("totalAlumni").textContent = alumniData.nodes.length;
            document.getElementById("totalConnections").textContent = totalConnections;
            document.getElementById("avgConnections").textContent = avgConnections;
            document.getElementById("mostConnected").textContent = mostConnected.name;
        }

        // Setup search functionality
        function setupSearch() {
            const alumniSelect = document.getElementById("alumniSelect");
            alumniSelect.addEventListener("change", (e) => {
                const selectedId = e.target.value;
                
                if (selectedId === "") {
                    resetSelection();
                    return;
                }

                const selectedNode = alumniData.nodes.find(node => node.id === selectedId);
                if (selectedNode) {
                    selectNode(e, selectedNode);
                    
                    // Center the view on selected node
                    const transform = d3.zoomIdentity
                        .translate(width / 2 - selectedNode.x, height / 2 - selectedNode.y)
                        .scale(1.5);
                    svg.transition().duration(750).call(
                        d3.zoom().transform, transform
                    );
                }
            });
        }

        // Control functions
        function resetZoom() {
            svg.transition().duration(750).call(
                d3.zoom().transform,
                d3.zoomIdentity
            );
        }

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            if (physicsEnabled) {
                simulation.alpha(0.3).restart();
            } else {
                simulation.stop();
            }
        }

        function centerNetwork() {
            const bounds = svg.node().getBBox();
            const fullWidth = bounds.width;
            const fullHeight = bounds.height;
            const width = +svg.attr("width");
            const height = +svg.attr("height");
            const midX = bounds.x + fullWidth / 2;
            const midY = bounds.y + fullHeight / 2;
            const scale = 0.8 / Math.max(fullWidth / width, fullHeight / height);
            const translate = [width / 2 - scale * midX, height / 2 - scale * midY];

            svg.transition().duration(750).call(
                d3.zoom().transform,
                d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
            );
        }

        // Handle window resize
        window.addEventListener("resize", () => {
            const container = d3.select("#networkContainer");
            const containerRect = container.node().getBoundingClientRect();
            width = containerRect.width;
            height = containerRect.height;
            
            svg.attr("width", width).attr("height", height);
            simulation.force("center", d3.forceCenter(width / 2, height / 2));
            simulation.alpha(0.3).restart();
        });

        // Initialize when page loads
        document.addEventListener("DOMContentLoaded", loadRealAlumniData);

        // Click outside to reset selection
        document.addEventListener("click", (e) => {
            if (!e.target.closest("#networkContainer") && !e.target.closest(".alumni-item")) {
                resetSelection();
            }
        });
    </script>
</body>
</html>
